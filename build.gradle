import groovy.transform.ToString
import groovy.transform.EqualsAndHashCode

/*  デフォルトでimport済みのパッケージ
import java.io.*
import java.lang.*
import java.math.BigDecimal
import java.math.BigInteger
import java.net.*
import java.util.*
import groovy.lang.*
import groovy.util.*
*/

//  末尾のセミコロン省略可能
Point a = new Point(10, 20)
Point b = new Point(3, 4)

//  特定の名前のメソッドは演算子記号で呼び出し可能
assert a + b == new Point(13, 24)
assert a - b == new Point(7, 16)
assert a * b == new Point(30, 80)
assert a / b == new Point(3, 5)
assert a++ == new Point(11, 21)
assert b-- == new Point(2, 3)
assert a << b == new Point(13, 24)

//  コンストラクタ呼び出し
def c = [1, 2] as Point
Point d = [3, 4]
Point e = new Point(x: 5, y: 6)
assert c == new Point(1, 2)
assert d == new Point(3, 4)
assert e == new Point(5, 6)

//  メソッド呼び出し時のかっこ省略可能（引数がない場合は省略不可）
def f = a.plus b 
def g = a.next()

//  メソッドパラメータをMapにすることで、名前付き指定のように呼び出し可能
assert Point.of(x :10, y: 20) == new Point(10, 20)

//  宣言時にアクセス修飾子やfinalを付けていないパラメータ以外は getter/setterは自動で生成される
a.setX(15)
a.setY(30)
assert a == new Point(15, 30)

//  シングルクォートは Character or String型に変換される
char s1 = 'x';  assert s1 instanceof Character
def s2 = 'x';   assert s2 instanceof String
def s3 = 'xy';  assert s3 instanceof String
//  ダブルクォートは String or GString型
def d1 = "x";   assert d1 instanceof String
def d2 = "xy";  assert d2 instanceof String
def d3 = "${a}";assert d3 instanceof GString 
//  Gstring は ${変数} で文字列に値を埋め込み可能。 == は equals で扱われる。
assert "a = ${a}" == "a = Point(15, 30)"

//  """でマルチライン文字列を生成可能
def d4 = """
一行目
二行目
""";
final def LF = System.lineSeparator()
assert d4 == "${LF}一行目${LF}二行目${LF}"

//  マルチライン文字列は \ と | と stripMargin() を使うとインデントがきれいにできる。
def d5 = """\
    |一行目
    |二行目
    |""".stripMargin()
assert d5 == "一行目${LF}二行目${LF}"

//  Closure(クロージャ)
def cl1 = {
    print "${x}, ${y}"
}
a.execute(cl1)

//  かっこは省略可能
b.execute {
    print "{${x}, ${y}}"
}

//  最後の引数がClosureの場合 メソッド名(){ ... }の形式で呼び出し可能。
//  Closureへの引数が1つの場合は it で呼び出し可能。
//  省略しない場合は メソッド名() { p -> ... }の形式となる。
a.execute(b) {
    int _x = x + it.x
    int _y = y + it.y
    print "${_x}, ${_y}"
}

(5..10).each {
    print it
}
println "";

(10).times {
    print it
}
println "";

//  ListやMap
def lm1 = [1, 2, 3]
assert lm1 instanceof ArrayList
assert lm1.sum() == 6

def lm2 = [x: 10, y: 11, z: 12] 
assert lm2 instanceof HashMap
assert lm2['y'] == 11

//  展開ドット演算子
assert lm2*.value == [10, 11, 12]
assert lm2.collect { it.value } == [10, 11, 12]

@ToString
@EqualsAndHashCode
class Point {
    int x;
    int y;

    Point(int x = 0, int y = 0) {
        this.x = x
        this.y = y
    }

    Point plus(Point p) {
        if (p == null) return this
        new Point(x + p.x, y + p.y) //  return 省略可：　ブロックの最後の式がreturnされる
    }

    Point minus(Point p) {
        if (p == null) return this
        new Point(x - p.x, y - p.y)
    }

    Point multiply(Point p) {
        if (p == null) return this
        new Point(x * p.x, y * p.y)
    }

    Point div(Point p) throws Exception {
        if (p == null) return this
        try {
            new Point(x / p.x as int, y / p.y as int)
        } catch (Exception e) {
            //  検査例外をthrowしても呼び出し側のcatch不要
            throw new Exception(e)
        }
    }

    Point next() {
        x++
        y++
        this
    }

    Point previous() {
        x--
        y--
        this
    }

    Point leftShift(Point p) {
        plus(p)
    }

    void execute(Closure c) {
        println "---"
        c.delegate = this
        c()
        println ""
        println "---"
    }

    void execute(Point p, Closure c) {
        println "---"
        c.delegate = this
        c(p)
        println ""
        println "---"
    }

    static Point of(Map m) {
        new Point(m['x'], m['y'])
    }
}

task hello {}